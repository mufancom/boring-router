{"version":3,"sources":["webpack:///../doc/references/service.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"mfAMO,IAAMA,EAAe,Q,2MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,WADR,WAGA,8BAAa,0BAAYC,WAAW,KAAvB,cAAb,kIACA,2JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wPAWL,kEACA,iBAAQ,CACN,GAAM,mBADR,mBAGA,sFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4sBAgCL,8BACE,iBAAGA,WAAW,cAAd,2DAAuF,mBAAGA,WAAW,KAAQ,CACzG,KAAQ,8CAD2E,mBAAvF,2BAIF,iBAAQ,CACN,GAAM,qBADR,qBAGA,oGAAmF,mBAAGA,WAAW,KAAQ,CACrG,KAAQ,qDADuE,0BAAnF,4DAGA,mOAAkN,0BAAYA,WAAW,KAAvB,cAAlN,qCACA,gEAA+C,0BAAYA,WAAW,KAAvB,cAA/C,WAAiH,0BAAYA,WAAW,KAAvB,iBAAjH,6CACA,8BACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,ykBAgCL,sDAAqC,0BAAYA,WAAW,KAAvB,QAArC,iDACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,uH,yMAUTJ,EAAWK,gBAAiB","file":"component---doc-references-service-md-833bba7afb863a702657.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/root/workspace/boring-router/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"service\"\n    }}>{`Service`}</h1>\n    <p>{`Every `}<inlineCode parentName=\"p\">{`RouteMatch`}</inlineCode>{` can be backed by a route service in Boring Router, providing additional flexibility with states comparing to lifecycle hooks.`}</p>\n    <p>{`A route service gets only \"activated\" when the route matches. And we can provide both pre-instantiated service or service factory:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route.account.$service(new AccountRouteService());\n\nroute.settings.$service(match => new SettingsRouteService(match));\n\nroute.workbench.$service(async match => {\n  // asynchronous code...\n  return new WorkbenchRouteService(match);\n});\n`}</code></pre>\n    <p>{`Service factory will be called on demand.`}</p>\n    <h2 {...{\n      \"id\": \"lifecycle-hooks\"\n    }}>{`Lifecycle Hooks`}</h2>\n    <p>{`Lifecycle hooks are supported by service as optional methods:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`type AccountRoute = typeof route.account;\n\nclass AccountRouteService implements IRouteService<AccountRoute> {\n  constructor(private match: AccountRoute) {}\n\n  async beforeEnter(next: AccountRoute['$next']): Promise<void> {}\n\n  async willEnter(next: AccountRoute['$next']): Promise<void> {}\n\n  async afterEnter(): void {}\n\n  async beforeUpdate(next: AccountRoute['$next']): Promise<void> {\n    this.beforeEnter(next);\n  }\n\n  async willUpdate(next: AccountRoute['$next']): Promise<void> {\n    this.willEnter(next);\n  }\n\n  async afterUpdate(): void {\n    this.afterEnter();\n  }\n\n  async beforeLeave(): Promise<void> {}\n\n  async willLeave(): Promise<void> {}\n\n  afterLeave(): void {}\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`For full signatures of lifecycle hook methods, checkout `}<a parentName=\"p\" {...{\n          \"href\": \"/boring-router/references/lifecycle-hooks\"\n        }}>{`Lifecycle Hooks`}</a>{` and type information.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"managed-extension\"\n    }}>{`Managed Extension`}</h2>\n    <p>{`We can add extension to a route with predefined values or getters (see also `}<a parentName=\"p\" {...{\n        \"href\": \"/boring-router/references/route-schema#extension\"\n      }}>{`Route Schema Extension`}</a>{`), and route service provides a way to manage extension.`}</p>\n    <p>{`When the route is matched, accessing an extension value will first access the correspondent value on the service instance. It the key does not exist on the service instance, it will then fallback to the `}<inlineCode parentName=\"p\">{`$extension`}</inlineCode>{` object provided by route schema.`}</p>\n    <p>{`Note only value with keys predefined in `}<inlineCode parentName=\"p\">{`$extension`}</inlineCode>{` (using `}<inlineCode parentName=\"p\">{`Object.keys()`}</inlineCode>{`) can be accessed through this mechanism.`}</p>\n    <p>{`E.g.:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  user: {\n    $children: {\n      userId: {\n        $match: /\\\\d+/,\n        $extension: {\n          user: undefined! as User,\n        },\n      },\n    },\n  },\n});\n\nroute.user.userId.$service(() => new UserIdRouteService());\n\ntype UserIdRoute = typeof route.user.userId;\n\nclass UserIdRouteService implements IRouteService<UserIdRoute> {\n  @observable\n  user!: User;\n\n  willEnter(next: UserIdRoute['$next']): void {\n    this.user = new User(next.$params.userId);\n  }\n\n  afterLeave(): void {\n    this.user = undefined!;\n  }\n}\n`}</code></pre>\n    <p>{`Thus we can easily access the `}<inlineCode parentName=\"p\">{`user`}</inlineCode>{` elsewhere. For example within route content:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`<Route match={route.user.userId}>\n  {match => <div>Hello, user {match.user.displayName}.</div>}\n</Route>\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
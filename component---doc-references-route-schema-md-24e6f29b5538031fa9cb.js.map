{"version":3,"sources":["webpack:///../doc/references/route-schema.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---doc-references-route-schema-md-24e6f29b5538031fa9cb.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/vilicvane/projects/boring-router/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"route-schema\"\n    }}>{`Route Schema`}</h1>\n    <h2 {...{\n      \"id\": \"overview\"\n    }}>{`Overview`}</h2>\n    <p>{`Boring Router defines routes by tree-structure route schemas:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $children: {\n        accountId: {\n          $match: /\\\\d+/,\n          $children: {\n            profile: {\n              $query: {\n                'show-comment': true,\n              },\n            },\n            contact: true,\n          },\n        },\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`The route defined above matches paths like below:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`/account/123/profile\n/account/123/profile?show-comment=on\n/account/456/contact\n`}</code></pre>\n    <p>{`And it creates route objects (`}<inlineCode parentName=\"p\">{`RouteMatch`}</inlineCode>{`) that can be accessed using:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route;\nroute.account;\nroute.account.accountId;\nroute.account.accountId.profile;\nroute.account.accountId.contact;\n`}</code></pre>\n    <p>{`To get a parameter (including segment parameter and query string) from a route, we need to access `}<inlineCode parentName=\"p\">{`$params`}</inlineCode>{` of the target route object.`}</p>\n    <p>{`In this case, to get `}<inlineCode parentName=\"p\">{`accountId`}</inlineCode>{`, we need to use `}<inlineCode parentName=\"p\">{`route.account.accountId.$params.accountId`}</inlineCode>{`. This might look a little bit weird at the beginning (maybe forever), but it's also reasonable: because `}<inlineCode parentName=\"p\">{`accountId`}</inlineCode>{` (the segment parameter) is one of the properties of route `}<inlineCode parentName=\"p\">{`route.account.accountId`}</inlineCode>{`, and its name by convention is the same as the route key.`}</p>\n    <p>{`We can also get the parameter from a child route object, e.g.: `}<inlineCode parentName=\"p\">{`route.account.accountId.profile.$params.accountId`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"match\"\n    }}>{`Match`}</h2>\n    <p>{`By adding a child under `}<inlineCode parentName=\"p\">{`$children`}</inlineCode>{`, we create a `}<inlineCode parentName=\"p\">{`RouteMatch`}</inlineCode>{` for the correspondent segment:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    // Simply use \\`true\\` for default options.\n    workbench: true,\n    // Specify route options with an object.\n    settings: {\n      $match: /boring/,\n      $children: {\n        security: true,\n        notification: true,\n      },\n    },\n  },\n});\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"segment-match\"\n    }}>{`Segment Match`}</h3>\n    <p>{`By default, Boring Router matches a segment according to the \"hyphenated\" string of the route key.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    // This matches \\`/user-settings\\`.\n    userSettings: true,\n  },\n});\n`}</code></pre>\n    <p>{`To match another fixed string, we may add a string `}<inlineCode parentName=\"p\">{`$match`}</inlineCode>{` option:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    // This matches \\`/settings\\`.\n    userSettings: {\n      $match: 'settings',\n    },\n  },\n});\n`}</code></pre>\n    <p>{`To make the segment a segment parameter, we may add `}<inlineCode parentName=\"p\">{`$match`}</inlineCode>{` option as regular expression:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    // This matches both \\`/settings\\` and \\`/user-settings\\`.\n    userSettings: {\n      $match: /(?:user-)?settings/,\n    },\n  },\n});\n`}</code></pre>\n    <p>{`And now we can get the actual matched segment by `}<inlineCode parentName=\"p\">{`route.userSettings.$params.userSettings`}</inlineCode>{`.`}</p>\n    <p>{`Please note that the regular expression must match the whole string of a segment. Assuming the path is `}<inlineCode parentName=\"p\">{`/settings-suffix`}</inlineCode>{`, even though `}<inlineCode parentName=\"p\">{`/(?:user-)?settings/.test('settings-suffix')`}</inlineCode>{` is true, but it won't match the route because the regular expression matches only `}<inlineCode parentName=\"p\">{`settings`}</inlineCode>{` instead of the whole segment `}<inlineCode parentName=\"p\">{`settings-suffix`}</inlineCode>{`.`}</p>\n    <h3 {...{\n      \"id\": \"exact-match\"\n    }}>{`Exact Match`}</h3>\n    <p>{`For route with children, by default it ignores the exact match. This means that the route defined in the `}<a parentName=\"p\" {...{\n        \"href\": \"#overview\"\n      }}>{`Overview`}</a>{` section does not match paths like:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`/account\n/account/123\n`}</code></pre>\n    <p>{`To allow exact match for those parent routes, we need to set `}<inlineCode parentName=\"p\">{`$exact`}</inlineCode>{` as `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` respectively.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $exact: true,\n      $children: {\n        /* ... */\n      },\n    },\n  },\n});\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"exact-match-default\"\n    }}>{`Exact Match Default`}</h3>\n    <p>{`Sometimes we might want a default child route to act as matched if its parent is exactly matched. E.g., for settings pages `}<inlineCode parentName=\"p\">{`/settings/user`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`/settings/organization`}</inlineCode>{`, we might want an exact match of `}<inlineCode parentName=\"p\">{`/settings`}</inlineCode>{` to act as if `}<inlineCode parentName=\"p\">{`/settings/user`}</inlineCode>{` is matched. And we may specify a string value for `}<inlineCode parentName=\"p\">{`$exact`}</inlineCode>{` to achieve that:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    settings: {\n      $exact: 'user',\n      $children: {\n        user: true,\n        organization: true,\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`Note this value is not specified according to the key but the path segment. So if the key of the child route is `}<inlineCode parentName=\"p\">{`awesomeUser`}</inlineCode>{`, the `}<inlineCode parentName=\"p\">{`$exact`}</inlineCode>{` value should be `}<inlineCode parentName=\"p\">{`awesome-user`}</inlineCode>{` with default configuration.`}</p>\n    <h2 {...{\n      \"id\": \"query\"\n    }}>{`Query`}</h2>\n    <p>{`The ability of handling query string in Boring Router is limited for now. It has some handy usages, but all `}<inlineCode parentName=\"p\">{`$query`}</inlineCode>{` definition is handled as optional strings without validations.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`This problem can be partially solved by `}<a parentName=\"p\" {...{\n          \"href\": \"/boring-router/references/route-schema#extension\"\n        }}>{`Extension`}</a>{` & `}<a parentName=\"p\" {...{\n          \"href\": \"/boring-router/references/service#managed-extension\"\n        }}>{`Service`}</a>{`.`}</p>\n    </blockquote>\n    <p>{`To get access to a specific query string, just add `}<inlineCode parentName=\"p\">{`$query`}</inlineCode>{` options and set a `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` value of the desired key:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        group: true,\n        id: true,\n      },\n      $children: {\n        profile: true,\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`Just like segment parameter, we can get a query string from `}<inlineCode parentName=\"p\">{`$params`}</inlineCode>{`. In this case, from both the route declaring the query string and its child route:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route.account.$params.group;\nroute.account.$params.id;\nroute.account.profile.$params.group;\nroute.account.profile.$params.id;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"query-string-preservation\"\n    }}>{`Query String Preservation`}</h3>\n    <p>{`By default, route builder (when you click a `}<inlineCode parentName=\"p\">{`<Link>`}</inlineCode>{` or trigger `}<inlineCode parentName=\"p\">{`RouteMatch#$ref()`}</inlineCode>{` directly or indirectly) keeps query strings declared at the next matching route when creating a new \"ref\" for navigation. Think of the example below:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        source: true,\n      },\n    },\n    about: {\n      $query: {\n        source: true,\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`If the current route matches `}<inlineCode parentName=\"p\">{`/account?source=123`}</inlineCode>{`, the result of `}<inlineCode parentName=\"p\">{`route.about.$ref()`}</inlineCode>{` would be `}<inlineCode parentName=\"p\">{`/about?source=123`}</inlineCode>{`.`}</p>\n    <p>{`We can provide specific query IDs for different queries to achieve more accurate query string preservation:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        source: 'account-source',\n      },\n    },\n    about: {\n      $query: {\n        source: 'about-source',\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`A query ID could be either a string or a symbol. If `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` is provided, it will always preserve query string with the same key or be preserved by other query string with the same key.`}</p>\n    <h2 {...{\n      \"id\": \"metadata\"\n    }}>{`Metadata`}</h2>\n    <p>{`You may add metadata to a specific route and its child route will automatically inherit the metadata.`}</p>\n    <p>{`For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    user: {\n      $metadata: {\n        title: 'User',\n      },\n      $exact: true,\n      $children: {\n        settings: {\n          $metadata: {\n            subTitle: 'Settings',\n          },\n        },\n      },\n    },\n    workbench: {\n      $metadata: {\n        title: 'Workbench',\n      },\n    },\n  },\n});\n\nroute.user.$metadata; // {title: 'User'}\nroute.user.settings.$metadata; // {title: 'User', subTitle: 'Settings'}\n`}</code></pre>\n    <p>{`Then we can use the metadata to update page title once the route changes:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route.$afterEnterOrUpdate(\n  () => {\n    let {title, subTitle} = route.$rest.$metadata as {\n      title: string;\n      subTitle?: string;\n    };\n\n    document.title = \\`\\${subTitle ? \\`\\${subTitle} | \\` : ''}\\${title}\\`;\n  },\n  {traceDescendants: true},\n);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"extension\"\n    }}>{`Extension`}</h2>\n    <p>{`Boring Router provides a way to add addition property to a specific route through `}<inlineCode parentName=\"p\">{`$extension`}</inlineCode>{` route option:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    user: {\n      $query: {\n        id: true,\n      },\n      $extension: {\n        get user() {\n          return new User(route.user.$params.id);\n        },\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`One of our common use case is just to provide type information with `}<inlineCode parentName=\"p\">{`$extension`}</inlineCode>{` and later have a route service to manage the actual value, with which more options are provided.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    user: {\n      $query: {\n        id: true,\n      },\n      $extension: {\n        user: undefined! as User,\n      },\n    },\n  },\n});\n\nroute.user.$service(match => new UserRouteService(match));\n\ntype UserRoute = typeof route.user;\n\nclass UserRouteService implements IRouteService<UserRoute> {\n  @observable\n  user!: User;\n\n  constructor(private match: UserRoute) {}\n\n  async willEnter(next: UserRoute['$next']): Promise<void> {\n    this.user = await getUser(next.$params.id);\n  }\n\n  afterLeave(): void {\n    this.user = undefined!;\n  }\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Checkout `}<a parentName=\"p\" {...{\n          \"href\": \"/boring-router/references/service\"\n        }}>{`Service`}</a>{` for more information.`}</p>\n    </blockquote>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
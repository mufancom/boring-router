{"version":3,"sources":["webpack:///../doc/references/route-schema.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---doc-references-route-schema-md-b8e8c8ceaf13cc33b169.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/vilicvane/projects/makeflow/boring-router/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"route-schema\"\n    }}>{`Route Schema`}</h1>\n    <h2 {...{\n      \"id\": \"overview\"\n    }}>{`Overview`}</h2>\n    <p>{`Boring Router defines routes by tree-structure route schemas:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $children: {\n        accountId: {\n          $match: /\\\\d+/,\n          $children: {\n            profile: {\n              $query: {\n                'show-comment': true,\n              },\n            },\n            contact: true,\n          },\n        },\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`The route defined above matches paths like below:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`/account/123/profile\n/account/123/profile?show-comment=on\n/account/456/contact\n`}</code></pre>\n    <p>{`And it creates route objects (`}<inlineCode parentName=\"p\">{`RouteMatch`}</inlineCode>{`) that can be accessed using:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route;\nroute.account;\nroute.account.accountId;\nroute.account.accountId.profile;\nroute.account.accountId.contact;\n`}</code></pre>\n    <p>{`To get a parameter (including segment parameter and query string) from a route, we need to access `}<inlineCode parentName=\"p\">{`$params`}</inlineCode>{` of the target route object.`}</p>\n    <p>{`In this case, to get `}<inlineCode parentName=\"p\">{`accountId`}</inlineCode>{`, we need to use `}<inlineCode parentName=\"p\">{`route.account.accountId.$params.accountId`}</inlineCode>{`. This might look a little bit weird at the beginning (maybe forever), but it's also reasonable: because `}<inlineCode parentName=\"p\">{`accountId`}</inlineCode>{` (the segment parameter) is one of the properties of route `}<inlineCode parentName=\"p\">{`route.account.accountId`}</inlineCode>{`, and its name by convention is the same as the route key.`}</p>\n    <p>{`We can also get the parameter from a child route object, e.g.: `}<inlineCode parentName=\"p\">{`route.account.accountId.profile.$params.accountId`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"match\"\n    }}>{`Match`}</h2>\n    <p>{`By adding a child under `}<inlineCode parentName=\"p\">{`$children`}</inlineCode>{`, we create a `}<inlineCode parentName=\"p\">{`RouteMatch`}</inlineCode>{` for the correspondent segment:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    // Simply use \\`true\\` for default options.\n    workbench: true,\n    // Specify route options with an object.\n    settings: {\n      $match: /boring/,\n      $children: {\n        security: true,\n        notification: true,\n      },\n    },\n  },\n});\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"segment-match\"\n    }}>{`Segment Match`}</h3>\n    <p>{`By default, Boring Router matches a segment according to the \"hyphenated\" string of the route key.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    // This matches \\`/user-settings\\`.\n    userSettings: true,\n  },\n});\n`}</code></pre>\n    <p>{`To match another fixed string, we may add a string `}<inlineCode parentName=\"p\">{`$match`}</inlineCode>{` option:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    // This matches \\`/settings\\`.\n    userSettings: {\n      $match: 'settings',\n    },\n  },\n});\n`}</code></pre>\n    <p>{`To make the segment a segment parameter, we may add `}<inlineCode parentName=\"p\">{`$match`}</inlineCode>{` option as regular expression:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    // This matches both \\`/settings\\` and \\`/user-settings\\`.\n    userSettings: {\n      $match: /(?:user-)?settings/,\n    },\n  },\n});\n`}</code></pre>\n    <p>{`And now we can get the actual matched segment by `}<inlineCode parentName=\"p\">{`route.userSettings.$params.userSettings`}</inlineCode>{`.`}</p>\n    <p>{`Please note that the regular expression must match the whole string of a segment. Assuming the path is `}<inlineCode parentName=\"p\">{`/settings-suffix`}</inlineCode>{`, even though `}<inlineCode parentName=\"p\">{`/(?:user-)?settings/.test('settings-suffix')`}</inlineCode>{` is true, but it won't match the route because the regular expression matches only `}<inlineCode parentName=\"p\">{`settings`}</inlineCode>{` instead of the whole segment `}<inlineCode parentName=\"p\">{`settings-suffix`}</inlineCode>{`.`}</p>\n    <h3 {...{\n      \"id\": \"exact-match\"\n    }}>{`Exact Match`}</h3>\n    <p>{`For route with children, by default it ignores the exact match. This means that the route defined in the `}<a parentName=\"p\" {...{\n        \"href\": \"#overview\"\n      }}>{`Overview`}</a>{` section does not match paths like:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`/account\n/account/123\n`}</code></pre>\n    <p>{`To allow exact match for those parent routes, we need to set `}<inlineCode parentName=\"p\">{`$exact`}</inlineCode>{` as `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` respectively.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $exact: true,\n      $children: {\n        /* ... */\n      },\n    },\n  },\n});\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"exact-match-default\"\n    }}>{`Exact Match Default`}</h3>\n    <p>{`Sometimes we might want a default child route to act as matched if its parent is exactly matched. E.g., for settings pages `}<inlineCode parentName=\"p\">{`/settings/user`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`/settings/organization`}</inlineCode>{`, we might want an exact match of `}<inlineCode parentName=\"p\">{`/settings`}</inlineCode>{` to act as if `}<inlineCode parentName=\"p\">{`/settings/user`}</inlineCode>{` is matched. And we may specify a string value for `}<inlineCode parentName=\"p\">{`$exact`}</inlineCode>{` to achieve that:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    settings: {\n      $exact: 'user',\n      $children: {\n        user: true,\n        organization: true,\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`Note this value is not specified according to the key but the path segment. So if the key of the child route is `}<inlineCode parentName=\"p\">{`awesomeUser`}</inlineCode>{`, the `}<inlineCode parentName=\"p\">{`$exact`}</inlineCode>{` value should be `}<inlineCode parentName=\"p\">{`awesome-user`}</inlineCode>{` with default configuration.`}</p>\n    <h2 {...{\n      \"id\": \"query\"\n    }}>{`Query`}</h2>\n    <p>{`The ability of handling query string in Boring Router is limited for now. It has some handy usages, but all `}<inlineCode parentName=\"p\">{`$query`}</inlineCode>{` definition is handled as optional strings without validations.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`This problem can be partially solved by `}<a parentName=\"p\" {...{\n          \"href\": \"/boring-router/references/route-schema#extension\"\n        }}>{`Extension`}</a>{` & `}<a parentName=\"p\" {...{\n          \"href\": \"/boring-router/references/service#managed-extension\"\n        }}>{`Service`}</a>{`.`}</p>\n    </blockquote>\n    <p>{`To get access to a specific query string, just add `}<inlineCode parentName=\"p\">{`$query`}</inlineCode>{` options and set a `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` value of the desired key:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        group: true,\n        id: true,\n      },\n      $children: {\n        profile: true,\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`Just like segment parameter, we can get a query string from `}<inlineCode parentName=\"p\">{`$params`}</inlineCode>{`. In this case, from both the route declaring the query string and its child route:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route.account.$params.group;\nroute.account.$params.id;\nroute.account.profile.$params.group;\nroute.account.profile.$params.id;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"query-string-preservation\"\n    }}>{`Query String Preservation`}</h3>\n    <p>{`By default, route builder (when you click a `}<inlineCode parentName=\"p\">{`<Link>`}</inlineCode>{` or trigger `}<inlineCode parentName=\"p\">{`RouteMatch#$ref()`}</inlineCode>{` directly or indirectly) keeps query strings declared at the next matching route when creating a new \"ref\" for navigation. Think of the example below:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        source: true,\n      },\n    },\n    about: {\n      $query: {\n        source: true,\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`If the current route matches `}<inlineCode parentName=\"p\">{`/account?source=123`}</inlineCode>{`, the result of `}<inlineCode parentName=\"p\">{`route.about.$ref()`}</inlineCode>{` would be `}<inlineCode parentName=\"p\">{`/about?source=123`}</inlineCode>{`.`}</p>\n    <p>{`We can provide specific query IDs for different queries to achieve more accurate query string preservation:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        source: 'account-source',\n      },\n    },\n    about: {\n      $query: {\n        source: 'about-source',\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`A query ID could be either a string or a symbol. If `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` is provided, it will always preserve query string with the same key or be preserved by other query string with the same key.`}</p>\n    <h2 {...{\n      \"id\": \"metadata\"\n    }}>{`Metadata`}</h2>\n    <p>{`You may add metadata to a specific route and its child route will automatically inherit the metadata.`}</p>\n    <p>{`For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    user: {\n      $metadata: {\n        title: 'User',\n      },\n      $exact: true,\n      $children: {\n        settings: {\n          $metadata: {\n            subTitle: 'Settings',\n          },\n        },\n      },\n    },\n    workbench: {\n      $metadata: {\n        title: 'Workbench',\n      },\n    },\n  },\n});\n\nroute.user.$metadata; // {title: 'User'}\nroute.user.settings.$metadata; // {title: 'User', subTitle: 'Settings'}\n`}</code></pre>\n    <p>{`Then we can use the metadata to update page title once the route changes:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route.$afterEnterOrUpdate(\n  () => {\n    let {title, subTitle} = route.$rest.$metadata as {\n      title: string;\n      subTitle?: string;\n    };\n\n    document.title = \\`\\${subTitle ? \\`\\${subTitle} | \\` : ''}\\${title}\\`;\n  },\n  {traceDescendants: true},\n);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"extension\"\n    }}>{`Extension`}</h2>\n    <p>{`Boring Router provides a way to add addition property to a specific route through `}<inlineCode parentName=\"p\">{`$extension`}</inlineCode>{` route option:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    user: {\n      $query: {\n        id: true,\n      },\n      $extension: {\n        get user() {\n          return new User(route.user.$params.id);\n        },\n      },\n    },\n  },\n});\n`}</code></pre>\n    <p>{`One of our common use case is just to provide type information with `}<inlineCode parentName=\"p\">{`$extension`}</inlineCode>{` and later have a route service to manage the actual value, with which more options are provided.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const route = router.$route({\n  $children: {\n    user: {\n      $query: {\n        id: true,\n      },\n      $extension: {\n        user: undefined! as User,\n      },\n    },\n  },\n});\n\nroute.user.$service(match => new UserRouteService(match));\n\ntype UserRoute = typeof route.user;\n\nclass UserRouteService implements IRouteService<UserRoute> {\n  @observable\n  user!: User;\n\n  constructor(private match: UserRoute) {}\n\n  async willEnter(next: UserRoute['$next']): Promise<void> {\n    this.user = await getUser(next.$params.id);\n  }\n\n  afterLeave(): void {\n    this.user = undefined!;\n  }\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Checkout `}<a parentName=\"p\" {...{\n          \"href\": \"/boring-router/references/service\"\n        }}>{`Service`}</a>{` for more information.`}</p>\n    </blockquote>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
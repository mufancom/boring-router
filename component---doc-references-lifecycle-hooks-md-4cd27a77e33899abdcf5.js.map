{"version":3,"sources":["webpack:///../doc/references/lifecycle-hooks.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","href","target","isMDXComponent"],"mappings":"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","file":"component---doc-references-lifecycle-hooks-md-4cd27a77e33899abdcf5.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/vilicvane/projects/makeflow/boring-router/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"lifecycle-hooks\"\n    }}>{`Lifecycle Hooks`}</h1>\n    <h2 {...{\n      \"id\": \"overview\"\n    }}>{`Overview`}</h2>\n    <p>{`Boring Router is a state-first router of which the core has nothing to do with React components. This makes Boring Router fundamentally different with `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/ReactTraining/react-router\"\n      }}>{`React Router`}</a>{` and removes the first barrier providing full lifecycle hooks.`}</p>\n    <p>{`The second barrier of full lifecycle hooks support is browser history stack. As navigation can happen without accessing the router managed by us (e.g., user clicking \"back\", \"forward\" and even \"goto\"), it is unavoidable for lifecycle hooks like `}<inlineCode parentName=\"p\">{`beforeEnter`}</inlineCode>{` to be called after the navigation actually happens. To support `}<inlineCode parentName=\"p\">{`before`}</inlineCode>{` hooks, we need to acquire the ability to restore history stack to a previous state. Otherwise, we will have broken browser navigation behavior. To solve this problem, we choose to implement our own `}<inlineCode parentName=\"p\">{`BrowserHistory`}</inlineCode>{` with the ability to track and restore history stack instead of using the popular `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/ReactTraining/history\"\n      }}>{`history`}</a>{` package.`}</p>\n    <p>{`Those make it possible for Boring Router to support full lifecycle hooks: `}<inlineCode parentName=\"p\">{`before/will/after`}</inlineCode>{` x `}<inlineCode parentName=\"p\">{`enter/update/leave`}</inlineCode>{`.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Check out an example `}<a href=\"https://codesandbox.io/s/github/makeflow/boring-router/tree/master/packages/examples/lifecycle-hooks?file=/main.tsx&amp;expanddevtools=1\" target=\"_blank\">{`here`}</a>{`.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"hook-phases\"\n    }}>{`Hook Phases`}</h2>\n    <h3 {...{\n      \"id\": \"before-hooks\"\n    }}>{`Before Hooks`}</h3>\n    <p>{`\"Before hooks\" (`}<inlineCode parentName=\"p\">{`beforeEnter`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`beforeUpdate`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`beforeLeave`}</inlineCode>{`) are called before applying a navigation. All of the \"before hooks\" support asynchronous callbacks and allow cancellation or interruption in between. This means if another navigation is queued before \"before\" phase completes, the current navigation will be interrupted.`}</p>\n    <p>{`So besides returning `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{` in a \"before hook\" to cancel a navigation, it is designed to allow additional navigation within a \"before hook\" to interrupt current navigation:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route.task.numericId.$beforeEnter(async next => {\n  let id = await getTaskIdByNumericId(next.$params.numericId);\n  route.task.id.$replace({id});\n});\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"will-hooks\"\n    }}>{`Will Hooks`}</h3>\n    <p>{`\"Will hooks\" (`}<inlineCode parentName=\"p\">{`willEnter`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`willUpdate`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`willLeave`}</inlineCode>{`) are called once all the \"before hooks\" are called and the navigation has not been cancelled or interrupted. \"Will hooks\" can also be asynchronous. But unlike \"before hooks\", it cannot cancel or interrupt a happening navigation. If another navigation is queued before \"will\" phase completes, it will be processed after the current navigation completes.`}</p>\n    <h3 {...{\n      \"id\": \"after-hooks\"\n    }}>{`After Hooks`}</h3>\n    <p>{`\"After hooks\" (`}<inlineCode parentName=\"p\">{`afterEnter`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`afterUpdate`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`afterLeave`}</inlineCode>{`) are called just before navigation completes. The wording \"after\" is still considered accurate, because at this phase the route states have already been updated. \"After hooks\" are synchronous hooks, you can do anything you want in those hooks as it's no longer within the scope of Boring Router.`}</p>\n    <h2 {...{\n      \"id\": \"hook-types\"\n    }}>{`Hook Types`}</h2>\n    <h3 {...{\n      \"id\": \"enter-hooks\"\n    }}>{`Enter Hooks`}</h3>\n    <p>{`\"Enter hooks\" (`}<inlineCode parentName=\"p\">{`beforeEnter`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`willEnter`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`afterEnter`}</inlineCode>{`) are called during a navigation that turns specific routes from not matched to matched (`}<inlineCode parentName=\"p\">{`$matched`}</inlineCode>{`). Entering a child route will also enter its parent route. E.g.:`}</p>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`/account`}</inlineCode>{` -> `}<inlineCode parentName=\"li\">{`/settings/security`}</inlineCode>{` will have \"enter hooks\" correspondent to `}<inlineCode parentName=\"li\">{`/settings`}</inlineCode>{` and `}<inlineCode parentName=\"li\">{`/settings/security`}</inlineCode>{` be called.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`/settings/security`}</inlineCode>{` -> `}<inlineCode parentName=\"li\">{`/settings/notification`}</inlineCode>{` will only have \"enter hooks\" correspondent to `}<inlineCode parentName=\"li\">{`/settings/notification`}</inlineCode>{` be called.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"update-hooks\"\n    }}>{`Update Hooks`}</h3>\n    <p>{`\"Update hooks\" (`}<inlineCode parentName=\"p\">{`beforeUpdate`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`willUpdate`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`afterUpdate`}</inlineCode>{`) are called during a navigation that updates specific routes. There are several situations:`}</p>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`/account/123`}</inlineCode>{` -> `}<inlineCode parentName=\"li\">{`/account/456`}</inlineCode>{` will have \"update hooks\" correspondent to `}<inlineCode parentName=\"li\">{`/account/:account-id`}</inlineCode>{` be called. \"Update hooks\" on route `}<inlineCode parentName=\"li\">{`/account`}</inlineCode>{` are not called, because its own states or parameters are not changed.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`/account/123/profile`}</inlineCode>{` -> `}<inlineCode parentName=\"li\">{`/account/456/profile`}</inlineCode>{` will have \"update hooks\" correspondent to `}<inlineCode parentName=\"li\">{`/account/:account-id`}</inlineCode>{` and `}<inlineCode parentName=\"li\">{`/account/:account-id/profile`}</inlineCode>{` be called. Because the `}<inlineCode parentName=\"li\">{`profile`}</inlineCode>{` route inherits parameters from its parent.`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`/account`}</inlineCode>{` -> `}<inlineCode parentName=\"li\">{`/account/123`}</inlineCode>{` (or vice versa) will have \"update hooks\" correspondent to `}<inlineCode parentName=\"li\">{`/account`}</inlineCode>{` be called. This is because the state `}<inlineCode parentName=\"li\">{`$exact`}</inlineCode>{` of route `}<inlineCode parentName=\"li\">{`/account`}</inlineCode>{` changes from `}<inlineCode parentName=\"li\">{`true`}</inlineCode>{` to `}<inlineCode parentName=\"li\">{`false`}</inlineCode>{`.`}</li>\n    </ul>\n    <p>{`Note that query changes `}<strong parentName=\"p\">{`WILL NOT`}</strong>{` trigger \"update hooks\", however `}<inlineCode parentName=\"p\">{`$params`}</inlineCode>{` are of course observable.`}</p>\n    <h3 {...{\n      \"id\": \"leave-hooks\"\n    }}>{`Leave Hooks`}</h3>\n    <p>{`\"Leave hooks\" (`}<inlineCode parentName=\"p\">{`beforeLeave`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`willLeave`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`afterLeave`}</inlineCode>{`) are called during a navigation that turns specific routes from matched (`}<inlineCode parentName=\"p\">{`$matched`}</inlineCode>{`) to the other way.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}